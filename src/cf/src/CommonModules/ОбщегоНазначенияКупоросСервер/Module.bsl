#Область ПрограммныйИнтерфейс

////////////////////////////////////////////////////////////////////////////////
// ФУНКЦИОНАЛЬНЫЕ

// Возвращает ссылку на незаписанный объект. Использовать в модулях объектов ПередЗаписью
//
// Параметры:
//  Ссылка	 - ЛюбаяСсылка
//
// Возвращаемое значение:
//  ЛюбаяСсылка - В случае если уже ранее был записан, то ссылка такая же
//
Функция СсылкаНаНезаписанныйОбъект(ЭтотОбъект, Ссылка) Экспорт
	
	Если Не ЗначениеЗаполнено(Ссылка) Тогда
		
		СсылкаНаОбъект = ЭтотОбъект.ПолучитьСсылкуНового();
		Если Не ЗначениеЗаполнено(СсылкаНаОбъект) Тогда
			
			Менеджер = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Ссылка);
			СсылкаНаОбъект = Менеджер.ПолучитьСсылку();
			ЭтотОбъект.УстановитьСсылкуНового(СсылкаНаОбъект);
			
		КонецЕсли;
		
	Иначе
		
		СсылкаНаОбъект = Ссылка;
		
	КонецЕсли;
	
	Возврат СсылкаНаОбъект;
	
КонецФункции // СсылкаНаНезаписанныйОбъект()

// Проверяет, что на текущий момент нет активных транзакций.
// Если транзакции есть, то записывает ошибку в журнал регистрации и вызывает исключение.
// Применяется в тех случаях когда нужно прервать выполнение кода, если он выполняется в транзакции.
//
Процедура ПроверитьОтсутствиеТранзакции() Экспорт
	
	Если Не ТранзакцияАктивна() Тогда
		
		Возврат;
		
	КонецЕсли;
	
	Попытка
		
		// Вызовем исключение в попытке, чтобы получить стек вызовов для записи в журнал регистрации.
		ТекстОшибки = НСтр("ru = 'Выполнение данной операции в транзакции запрещено.'");
		ВызватьИсключение ТекстОшибки;
		
	Исключение
	    
		КодЯзыка = ОбщегоНазначения.КодОсновногоЯзыка();
		ИмяСобытия = НСтр("ru = 'Запрет выполнения в транзакции'", КодЯзыка);
		
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ТекстОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		
		ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки, РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
		
		// Вызовем повторное исключение, чтобы прервать операцию.
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Устарела. Следует использовать ЗаполнитьЗаписьЖурналаРегистрации(). Быстрая запись в журнал регистрации. Использовать из шаблона разработчика.
//
// Параметры:
//  ИмяСобытияВход				 - Строка - Состоит из <Подразделение>.<Функционал/Процедура> 
//  ТекстОписания				 - Строка - любое текстовое пояснение
//  Уровень						 - УровеньЖурналаРегистрации - для ошибок: УровеньЖурналаРегистрации.Ошибка
//  ВыводитьПредставлениеОшибки	 - Булево - если процедура вызывается в исключении попытки, то устанавливать Истина для вывода информации по ошибке
//
Процедура ЗаписьЖурналаРегистрацииРасширенная(ИмяСобытияВход, ТекстОписания, Уровень, ВыводитьПредставлениеОшибки = Ложь) Экспорт

	КодЯзыка = ОбщегоНазначения.КодОсновногоЯзыка();
	ИмяСобытия = СтрШаблон(НСтр("ru = '%1'", КодЯзыка), ИмяСобытияВход);
	
	Если ВыводитьПредставлениеОшибки Тогда
	
		ТекстКомментария = НСтр("ru = '%1 
                    |%2'", КодЯзыка);

		КомментарийДляЖурнала = СтрШаблон(ТекстКомментария,
									ТекстОписания,	
									ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	Иначе
									
		ТекстКомментария = НСтр("ru = '%1'", КодЯзыка);

		КомментарийДляЖурнала = СтрШаблон(ТекстКомментария,
									ТекстОписания);
	
	КонецЕсли;
									
	ЗаписьЖурналаРегистрации(ИмяСобытия, Уровень,,, КомментарийДляЖурнала);

КонецПроцедуры 

// Быстрая запись в журнал регистрации 2025. Использовать из шаблона разработчика.
//
// Параметры:
//  ИмяСобытияВход				 - Строка - Состоит из <Подразделение>.<Функционал/Процедура> 
//  ТекстОписания				 - Строка - любое текстовое пояснение
//  Уровень						 - УровеньЖурналаРегистрации - для ошибок: УровеньЖурналаРегистрации.Ошибка
//  ПопыткаИсключения	 		 - Булево - если процедура вызывается в исключении попытки, то устанавливать Истина для вывода информации по ошибке
//	ИнформацияОбОшибке 			 - ИнформацияОбОшибке - передается в случае использования Попытка/Исключение из блока Исключения 
//	ДополнительныеПараметры 	 - Структура:
//  	* ОбъектМетаданных		 - ОбъектМетаданных - объекты метаданных конфигуратора
//  	* Данные			     - ЛюбаяСсылка - ссылка на проблемный объект
// Возвращаемое значение:
//  Структура - результат записи в журнал регистрации:
//		* КомментарийДляЖурналаРегистрации - Строка
//		* ИмяСобытия - Строка
//		* Уровень - УровеньЖурналаРегистрации
//		* ОбъектМетаданных - ОбъектМетаданных
//		* Данные - ЛюбойТип
//
Функция ЗаполнитьЗаписьЖурналаРегистрации(ИмяСобытияВход, ТекстОписания, Уровень, 
		ПопыткаИсключения = Ложь, ИнформацияОбОшибке = Неопределено, ДополнительныеПараметры = Неопределено) Экспорт
		
	КодЯзыка = ОбщегоНазначения.КодОсновногоЯзыка();
	ИмяСобытия = СтрШаблон(НСтр("ru = '%1'", КодЯзыка), ИмяСобытияВход);
	
	Если ПопыткаИсключения Тогда
		
		ТекстКомментария = НСтр("ru = '%1: 
		|%2'", КодЯзыка);
		
		ТекущаяИнформацияОбОшибке = ?(ИнформацияОбОшибке = Неопределено, ИнформацияОбОшибке(), ИнформацияОбОшибке);
		
		КомментарийДляЖурнала = СтрШаблон(ТекстКомментария,
			ТекстОписания,	
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ТекущаяИнформацияОбОшибке));
	Иначе
		
		ТекстКомментария = НСтр("ru = '%1'", КодЯзыка);
		
		КомментарийДляЖурнала = СтрШаблон(ТекстКомментария,
		ТекстОписания);
		
	КонецЕсли;
	
	ОбъектМетаданных = Неопределено;
	Данные = Неопределено;
	Если ЗначениеЗаполнено(ДополнительныеПараметры) Тогда
		ДополнительныеПараметры.Свойство("ОбъектМетаданных", ОбъектМетаданных);	
		ДополнительныеПараметры.Свойство("Данные", Данные);	
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(ИмяСобытия, Уровень, ОбъектМетаданных, Данные, КомментарийДляЖурнала);
	
	ПараметрыРезультата = Новый Структура;
	ПараметрыРезультата.Вставить("КомментарийДляЖурналаРегистрации", КомментарийДляЖурнала);
	ПараметрыРезультата.Вставить("ИмяСобытия", ИмяСобытия);
	ПараметрыРезультата.Вставить("Уровень", Уровень);
	ПараметрыРезультата.Вставить("ОбъектМетаданных", ОбъектМетаданных);
	ПараметрыРезультата.Вставить("Данные", Данные);
	
	Возврат ПараметрыРезультата;

КонецФункции

// Устанавливает свойство объекта из структуры-источника, если в источнике есть это свойство.
//
// Параметры:
//  Приемник					 - Произвольный - любой объект, к свойствам которого можно обращаться через квадратные скобки [].
//  СтруктураИсточник			 - Структура - источник, из которого берется значение свойства.
//  ИмяСвойства					 - Строка - имя свойства приемника, которое нужно установить.
//  ИмяСвойстваИсточника		 - Строка - имя свойства источника. Если не заполнено, то используется имя свойства приемника.
//  ТолькоЗаполненноеЗначение	 - Истина - свойство будет установлено только в том случае, если оно заполнено в источнике.
// 
// Возвращаемое значение:
//  Булево - Истина - свойство установлено, Ложь - не установлено.
//
Функция УстановитьЗначениеСвойстваИзСтруктуры(Приемник, СтруктураИсточник, ИмяСвойства, 
		Знач ИмяСвойстваИсточника = Неопределено, ТолькоЗаполненноеЗначение = Ложь) Экспорт
	
	Если ИмяСвойстваИсточника = Неопределено Тогда
		
		ИмяСвойстваИсточника = ИмяСвойства;
		
	КонецЕсли;
	
	Если Не СтруктураИсточник.Свойство(ИмяСвойстваИсточника) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	ЗначениеСвойства = СтруктураИсточник[ИмяСвойстваИсточника];
	
	Если ТолькоЗаполненноеЗначение
		И Не ЗначениеЗаполнено(ЗначениеСвойства) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Приемник[ИмяСвойства] = ЗначениеСвойства;
	
	Возврат Истина;
	
КонецФункции

// Возвращает пустой уникальный идентификатор (состоит из нулей).
//
// Параметры:
//  ВВидеСтроки	 - Булево	 - Истина, результат будет в виде строки
// 
// Возвращаемое значение:
//  Строка, УникальныйИдентификатор - результат в виде пустого уникального идентификатора 
//
Функция ПустойУникальныйИдентификатор(ВВидеСтроки = Ложь) Экспорт
	
	ИдентификаторСтрокой = "00000000-0000-0000-0000-000000000000";
	
	Если ВВидеСтроки Тогда
		
		Возврат ИдентификаторСтрокой;
		
	Иначе
		
		Возврат Новый УникальныйИдентификатор(ИдентификаторСтрокой);
		
	КонецЕсли;
	
КонецФункции

// Возвращает тип значения для свойства XDTO.
//
// Параметры:
//  СвойствоXDTO - СвойствоXDTO	 - Свойство объекта XDTO.
// 
// Возвращаемое значение:
//  Структура:
//  * Тип - Строка - тип объекта как он указан для свойства XDTO.
//  * ДлинаСтроки - Строка - длина строки, если тип свойства "string".
//
Функция ОписаниеТипаСвойстваXDTO(СвойствоXDTO) Экспорт
	
	ОписаниеТипа = Новый Структура;
	
	Если ЗначениеЗаполнено(СвойствоXDTO.Тип.Имя) Тогда
		
		ТипЗначения = СвойствоXDTO.Тип.Имя;
		
	Иначе
		
		ТипЗначения = СвойствоXDTO.Тип.БазовыйТип.Имя;
		
	КонецЕсли;
	
	ОписаниеТипа.Вставить("Тип", ТипЗначения);
	
	Если ТипЗначения = "string" Тогда
		
		ДлинаСтроки = СвойствоXDTO.Тип.Фасеты.Получить(ВидФасетаXDTO.МаксДлина);
		
		Если ДлинаСтроки = Неопределено Тогда
			
			ДлинаСтроки = 0;
			
		Иначе
			
			ТипЧисло = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(10, 0, ДопустимыйЗнак.Неотрицательный));
			ДлинаСтроки = ТипЧисло.ПривестиЗначение(ДлинаСтроки.Значение);
			
		КонецЕсли;
		
		ОписаниеТипа.Вставить("ДлинаСтроки", ДлинаСтроки);
		
	КонецЕсли;
	
	Возврат ОписаниеТипа;
	
КонецФункции

// Фильтр возможных расширений изображений для использования в диалоге выбора файлов.
// 
// Возвращаемое значение:
//  Строка - 
//
Функция ФильтрРасширенийИзображений() Экспорт
	
	Фильтр = НСтр("ru = 'Все картинки (*.bmp;*.gif;*.png;*.jpeg;*.dib;*.rle;*.tif;*.jpg;*.ico;*.wmf;*.emf)|*.bmp;*.gif;*.png;*.jpeg;*.dib;*.rle;*.tif;*.jpg;*.ico;*.wmf;*.emf
                   |Все файлы(*.*)|*.*
                   |Формат bmp(*.bmp*;*.dib;*.rle)|*.bmp;*.dib;*.rle
                   |Формат GIF(*.gif*)|*.gif
                   |Формат JPEG(*.jpeg;*.jpg)|*.jpeg;*.jpg
                   |Формат PNG(*.png*)|*.png
                   |Формат TIFF(*.tif)|*.tif
                   |Формат icon(*.ico)|*.ico
                   |Формат метафайл(*.wmf;*.emf)|*.wmf;*.emf'");
	
	Возврат Фильтр; 
	
КонецФункции

// Преобразует дату в метку времени Unix (Unix Timestamp).
//
// Параметры:
//  Дата		 - Дата -
//  ВВидеСтроки	 - Булево - Истина - метка времени будет возвращена в виде строки, Ложь - в виде числа.
// 
// Возвращаемое значение:
//  Число, Строка
//
Функция TimeStamp(Дата, ВВидеСтроки = Ложь) Экспорт
	
	КрайняяДата = '19700101'; 
	Результат = Дата - КрайняяДата;
	
	Если ВВидеСтроки Тогда
		
		Результат = Формат(Результат, "ЧГ=");
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Все параметры Купорос из регистра ПараметрыКупорос
// 
// Возвращаемое значение:
//   РегистрСведенийЗапись.ПараметрыКупорос - параметры доступные для использования
//
Функция ПараметрыКупорос() Экспорт

	Возврат РегистрыСведений.ПараметрыКупорос.Параметры();

КонецФункции

// Возвращает одно значение параметра из регистра ПараметрыКупорос
//
// Параметры:
//  Параметр - Строка	 - имя параметра
// 
// Возвращаемое значение:
//  ЛюбоеЗначение - результат получения значения
//
Функция ЗначениеПараметраКупорос(Параметр) Экспорт

	Возврат РегистрыСведений.ПараметрыКупорос.ЗначениеПараметра(Параметр);

КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПЕРЕОПРЕДЕЛЕНИЕ ФОРМЫ ВЫБОРА НА ФОРМУ СПИСКА

// Устанавливает режим выбора для формы, если в объекте в качестве формы выбора используется форма списка.
// Работает совместно с подпиской ПереопределитьФормуВыбораКупорос.
//
// Параметры:
//  Форма				 - УправляемаяФорма - форма объекта, которая открывается в качестве формы выбора.
//  Отказ				 - Булево - см. обработчик события ПриСозданииНаСервере
//  СтандартнаяОбработка - Булево - см. обработчик события ПриСозданииНаСервере
//
Процедура ПриСозданииНаСервереФормыВыбора(Форма, Отказ, СтандартнаяОбработка) Экспорт
	
	Если Не Форма.Параметры.РежимВыбора Тогда
		Возврат;	
	КонецЕсли;
	
	Форма.Элементы.Список.РежимВыбора = Форма.Параметры.РежимВыбора;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ОБЩИЕ РЕГЛАМЕНТНЫЕ ЗАДАНИЯ

// Регламентное задание. Загрузка электронных писем в документ "Электронные письма входящие"
Процедура ПолучениеЭлектронныхСообщений() Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.ПолучениеЭлектронныхСообщений);
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	УчетныеЗаписиЭлектроннойПочты.Ссылка КАК Ссылка
	               |ИЗ
	               |	Справочник.УчетныеЗаписиЭлектроннойПочты КАК УчетныеЗаписиЭлектроннойПочты
	               |ГДЕ
	               |	НЕ УчетныеЗаписиЭлектроннойПочты.ПометкаУдаления
	               |	И УчетныеЗаписиЭлектроннойПочты.ИспользоватьДляЗагрузкиВходящихЭлектронныхПисем
	               |	И УчетныеЗаписиЭлектроннойПочты.ИспользоватьДляПолучения";
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Документы.ЭлектронныеПисьмаВходящие.ЗагрузитьВходящиеПисьмаПоУчетнойЗаписи(Выборка.Ссылка);
		
	КонецЦикла;
	
КонецПроцедуры

// Регламентное задание. Обработка загруженных электронных писем (документ "Электронные письма входящие")
Процедура ОбработкаЭлектронныхСообщений() Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.ОбработкаЭлектронныхСообщений);
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
		|	ЭлектронныеПисьмаВходящие.Ссылка КАК Ссылка,
		|	ЭлектронныеПисьмаВходящие.ПометкаУдаления КАК ПометкаУдаления,
		|	ЭлектронныеПисьмаВходящие.Номер КАК Номер,
		|	ЭлектронныеПисьмаВходящие.Дата КАК Дата,
		|	ЭлектронныеПисьмаВходящие.Важность КАК Важность,
		|	ЭлектронныеПисьмаВходящие.ВнутреннийЗаголовок КАК ВнутреннийЗаголовок,
		|	ЭлектронныеПисьмаВходящие.ДатаПолучения КАК ДатаПолучения,
		|	ЭлектронныеПисьмаВходящие.ДатаОтправления КАК ДатаОтправления,
		|	ЭлектронныеПисьмаВходящие.ЕстьВложения КАК ЕстьВложения,
		|	ЭлектронныеПисьмаВходящие.ИдентификаторНаСервере КАК ИдентификаторНаСервере,
		|	ЭлектронныеПисьмаВходящие.Кодировка КАК Кодировка,
		|	ЭлектронныеПисьмаВходящие.ОтправительАдрес КАК ОтправительАдрес,
		|	ЭлектронныеПисьмаВходящие.ОтправительКонтакт КАК ОтправительКонтакт,
		|	ЭлектронныеПисьмаВходящие.ОтправительПредставление КАК ОтправительПредставление,
		|	ЭлектронныеПисьмаВходящие.Обработано КАК Обработано,
		|	ЭлектронныеПисьмаВходящие.Размер КАК Размер,
		|	ЭлектронныеПисьмаВходящие.Текст КАК Текст,
		|	ЭлектронныеПисьмаВходящие.ТекстHTML КАК ТекстHTML,
		|	ЭлектронныеПисьмаВходящие.Тема КАК Тема,
		|	ЭлектронныеПисьмаВходящие.ТипТекста КАК ТипТекста,
		|	ЭлектронныеПисьмаВходящие.УведомитьОДоставке КАК УведомитьОДоставке,
		|	ЭлектронныеПисьмаВходящие.УведомитьОПрочтении КАК УведомитьОПрочтении,
		|	ЭлектронныеПисьмаВходящие.СтруктураКартинок КАК СтруктураКартинок,
		|	ЭлектронныеПисьмаВходящие.ЧерезOutlook КАК ЧерезOutlook,
		|	ЭлектронныеПисьмаВходящие.ПочтовоеСообщениеОригинал КАК ПочтовоеСообщениеОригинал,
		|	ЭлектронныеПисьмаВходящие.УчетнаяЗапись КАК УчетнаяЗапись
		|ИЗ
		|	Документ.ЭлектронныеПисьмаВходящие КАК ЭлектронныеПисьмаВходящие
		|ГДЕ
		|	НЕ ЭлектронныеПисьмаВходящие.ПометкаУдаления
		|	И НЕ ЭлектронныеПисьмаВходящие.Обработано";
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Попытка
			
			Документы.ЭлектронныеПисьмаВходящие.ОбработатьВходящееПисьмо(Выборка);
			
		Исключение
			ТекстОшибки = СтрШаблон(НСтр("ru = 'Ошибка при обработке электронного письма: %1, %2'", ОбщегоНазначения.КодОсновногоЯзыка()),
					"" + Выборка.Ссылка, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Обработка входящих электронных писем'", ОбщегоНазначения.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ОБЩИЕ ФУНКЦИИ ОБМЕНА

// Возвращает текущий УзелОбмена для фиксации в объектах.
//
// Возвращаемое значение:
//   УникальныИдентификатор - идентификатор текущего узла (реквизит УИД в плане обмена ОбменВРаспределеннойИнформационнойБазе)
//
Функция ЭтотУзелОбменаДляКупорос() Экспорт
	
	ЭтотУзел = ОбменДаннымиПовтИсп.ПолучитьЭтотУзелПланаОбмена("ОбменВРаспределеннойИнформационнойБазе");
	
	Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ЭтотУзел, "ИдентификаторУзла");
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ РАБОТЫ С ДАТАМИ

// Функция проверки дублирования строк в табличных частях (может возвращать массив задублированных строк)
//
// Параметры:
//	Таблица		- <ТаблицаЗначений,ТабличнаяЧасть> - таблица в которой проверяется дублирование строк
//	Колонки		- <Строка> - имена колонок разделенных запятыми по которым нужно проверить дублирование строк.
//		Если имена колонок не указаны проверяется полное совпадение строк по всем колонкам.
//		ВАЖНО! Колонка с именем "НомерСтроки" не участвует в сравнении
//	МассивСтрок	- <Неопределено,Массив> - сюда передается массив задвоенных строк если таковые были, либо Неопределено
//	Ошибки		- <Строка> - сюда передается информация о найденных задвоениях колонок
//
// Возвращаемое значение:
//	<Булево,Неопределено> - Истина - есть задвоенные строки в таблице (параметр Ошибки содержит полную информацию);
//		Ложь - в таблице нет задвоенных строк; Неопределено - не верно указаны имена колонок для проверки
//
Функция ПроверитьДублированиеСтрокТаблицы(Таблица, Колонки = "", МассивСтрок = Неопределено, Ошибки = "") Экспорт
	
	// Если передали массив, значит нужно возвращать массив задублированных строк
	ВозвращатьЗадублированныеСтроки = ТипЗнч(МассивСтрок) = Тип("Массив");
	
	// Выгрузим во временную таблицу, оригинальная нам понадобится ниже
	Попытка
		Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
			ВремТаблицаЗначений = Таблица.Скопировать( , Колонки);
		Иначе
			ВремТаблицаЗначений = Таблица.Выгрузить( , Колонки);
		КонецЕсли;
	Исключение
		Ошибки = "Не верно указаны имена колонок!";
		Возврат Неопределено;
	КонецПопытки;
	
	ЕстьНомерСтроки = Таблица.Колонки.Найти("НомерСтроки") <> Неопределено;
	
	// Если колонки не указаны значит будем проверять на полное совпадение всех колонок
	Если Колонки = "" Тогда
		
		ВремКолонки = "";
		Для каждого Колонка Из ВремТаблицаЗначений.Колонки Цикл
			Если Колонка.Имя = "НомерСтроки" Тогда
				Продолжить;
			КонецЕсли;
			ВремКолонки = ВремКолонки + ?(ВремКолонки = "", "", ",") + Колонка.Имя;
		КонецЦикла;
		
	Иначе
		ВремКолонки = Колонки;
	КонецЕсли;
	
	// Случайный набор символов, чтобы не совпало с существующей колонкой
	СлучайноеИмяКолонки = "Количество_fhgeE";
	
	// Получим таблицу задублированных строк
	ВремТаблицаЗначений.Колонки.Добавить(СлучайноеИмяКолонки);
	ВремТаблицаЗначений.ЗаполнитьЗначения(1, СлучайноеИмяКолонки);
	ВремТаблицаЗначений.Свернуть(ВремКолонки, СлучайноеИмяКолонки);
	ВремТаблицаЗначений.Сортировать(СлучайноеИмяКолонки + " Убыв");
	
	ЕстьДубли = Ложь;
	
	Для каждого СтрокаТЗ Из ВремТаблицаЗначений Цикл
		
		// Если дошли до строк в которых нет дублей (количество = 1) дальше проверять не будем
		Если СтрокаТЗ[СлучайноеИмяКолонки] < 2 Тогда
			Прервать;
		КонецЕсли;
		
		ЕстьДубли = Истина;
		
		// Найдем строки которые дублируются, чтобы вывести их номера пользователю
		Отбор = Новый Структура;
		НазванияКолонок = "";
		
		Для каждого Колонка Из ВремТаблицаЗначений.Колонки Цикл
			
			Если Колонка.Имя = СлучайноеИмяКолонки Тогда
				Продолжить;
			КонецЕсли;
			
			Отбор.Вставить(Колонка.Имя, СтрокаТЗ[Колонка.Имя]);
			НазванияКолонок = НазванияКолонок + ?(НазванияКолонок = "", "", ",") + Колонка.Заголовок;
			
		КонецЦикла;
		
		НомераСтрок = "";
		НайденныеСтроки = Таблица.НайтиСтроки(Отбор);
		
		Для каждого НайденнаяСтрока Из НайденныеСтроки Цикл
			
			Если ЕстьНомерСтроки Тогда
				НомераСтрок = НомераСтрок + ?(НомераСтрок = "", "", ",") + Строка(НайденнаяСтрока.НомерСтроки);
			Иначе
				НомераСтрок = "Нет номеров строк";
			КонецЕсли;
			
			Если ВозвращатьЗадублированныеСтроки Тогда
				МассивСтрок.Добавить(НайденнаяСтрока);
			КонецЕсли;
			
		КонецЦикла;
		
		// Сформируем текст сообщения
		Если Колонки = "" Тогда
			ТекстОшибкиКолонки = ", строки полностью идентичны!";
		Иначе
			ТекстОшибкиКолонки = ", одинаковые значения в колонках [" + НазванияКолонок + "]!";
			КонецЕсли;
		
		Ошибки = Ошибки + ?(Ошибки = "", "", Символы.ПС) + "Задублированы строки: [" + НомераСтрок + "]" + ТекстОшибкиКолонки;
		
	КонецЦикла;
	
	Возврат ЕстьДубли;
	
КонецФункции

// Определение разности двух дат указанной размерности
//
// Параметры:
//  НачальнаяДата - Дата
//  КонечнаяДата - Дата
//  Размерность - Строка - Варианты: Месяц, День, Час, Секунда
//
// Возвращаемое значение:
//  Число - Разность дат
Функция РазностьДат(НачальнаяДата, КонечнаяДата, Размерность) Экспорт
	
	Запрос = Новый Запрос;
	Если ВРег(Размерность) = "СЕКУНДА" Тогда
		Запрос.Текст = "ВЫБРАТЬ
			|     РАЗНОСТЬДАТ(&НачальнаяДата, &КонечнаяДата, МИНУТА) * 60 + (СЕКУНДА(&КонечнаяДата) - СЕКУНДА(&НачальнаяДата)) КАК  Разность";
	Иначе
		Запрос.Текст = "ВЫБРАТЬ       
			|     РАЗНОСТЬДАТ(&НачальнаяДата, &КонечнаяДата, " + Размерность + ") КАК  Разность";
	КонецЕсли;
	
	Запрос.УстановитьПараметр("НачальнаяДата", НачальнаяДата);
	Запрос.УстановитьПараметр("КонечнаяДата", КонечнаяДата);
	
	Возврат Запрос.Выполнить().Выгрузить()[0].Разность;
	
КонецФункции

// Добавление к начальной дате единиц определенной размерности
//
// Параметры:
//  НачальнаяДата - Дата
//  Количество - Число
//  Размерность - Строка - Варианты: Месяц, Неделя, День, Час, Секунда
//
// Возвращаемое значение:
//  Дата - результат прибавления к дате
Функция ДобавитьКДате(НачальнаяДата, Количество, Размерность) Экспорт
	
	Запрос = Новый("Запрос");
	Запрос.Текст =
		"ВЫБРАТЬ
		|     ДОБАВИТЬКДАТЕ(&НачальнаяДата, " + Размерность + ",&Количество) КАК НоваяДата";
	Запрос.УстановитьПараметр("НачальнаяДата", НачальнаяДата);
	Запрос.УстановитьПараметр("Количество", Количество);
	Возврат Запрос.Выполнить().Выгрузить()[0].НоваяДата;
	
КонецФункции


//////////////////////////////////////////////////////////////////////////////////////////
// НАПОМИНАНИЯ ПОЛЬЗОВАТЕЛЯМ   #УведомлениеПоТелеграмВНапоминаниях, #УведомлениеПоЭлектроннойПочтеВНапоминаниях

// Регламентное задание. Выполняет проверку наличия активных напоминаний для пользователя (о которых надо уведомить) и уведомляет по Телеграм.
Процедура УведомлениеПоНапоминаниямЧерезПочту() Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.УведомлениеПоНапоминаниямЧерезПочту);
	
	УведомитьПользователейПоНапоминаниямПочты();
	
	Справочники.Сертификаты.ОбновлениеДанныхПоПросрочкеСертификатов();	
	
КонецПроцедуры

// Уведомить пользователей по напоминаниям почты
//
Процедура УведомитьПользователейПоНапоминаниямПочты() Экспорт
	
	ВидСообщения = НСтр("ru = 'НапоминанияПользователя.Уведомление по почте о событии'", ОбщегоНазначения.КодОсновногоЯзыка());
	
	СистемнаяУчетнаяЗапись = Справочники.УчетныеЗаписиЭлектроннойПочты.СистемнаяУчетнаяЗаписьЭлектроннойПочты;

	Если Не РаботаСПочтовымиСообщениями.УчетнаяЗаписьНастроена(СистемнаяУчетнаяЗапись) Тогда
		ОписаниеОшибки = НСтр("ru = 'Системная учетная запись электронной почты не настроена для отправки.'");
		ЗаписьЖурналаРегистрации(ВидСообщения, УровеньЖурналаРегистрации.Ошибка,
			Метаданные.РегламентныеЗадания.УведомлениеПоНапоминаниямЧерезПочту,, ОписаниеОшибки);
		Возврат;
	КонецЕсли;
	
	ТаблицаОповещений = СписокТекущихНапоминанийПользователейПочтаТелеграм(Истина, Ложь);
	
	Для Каждого Оповещение Из ТаблицаОповещений Цикл
		
		// - Отправка оповещения по электронной почте.
		ПочтовыйАдресПолучателя = УправлениеКонтактнойИнформацией.КонтактнаяИнформацияОбъекта(
				Оповещение.Пользователь, УправлениеКонтактнойИнформацией.ВидКонтактнойИнформацииПоИмени("EmailПользователя"));
		
		Если ПустаяСтрока(ПочтовыйАдресПолучателя) Тогда
			ЗаписьЖурналаРегистрации(ВидСообщения,
				УровеньЖурналаРегистрации.Информация, , ,
				СтрШаблон(НСтр("ru = 'Уведомление не отправлено, так как не указан почтовый адрес у пользователя %1.'"), Строка(Оповещение.Пользователь)));
			Продолжить;
		КонецЕсли;
		
		ТемаПисьма = СтрШаблон(НСтр("ru = '⚡Напоминание о событии по ""%1""'"), Оповещение.Источник);
		
		ТекстСообщения = НСтр("ru = '[Напоминание по ""%1"", время события уведомления %2]
				|%3'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, Оповещение.Источник, Оповещение.ВремяСобытия, Оповещение.Описание);
		ТекстПисьма = ТекстВHTML(ТекстСообщения);
		
		ПараметрыПисьма = Новый Структура;
		ПараметрыПисьма.Вставить("Тема", ТемаПисьма);
		ПараметрыПисьма.Вставить("Тело", ТекстПисьма);
		ПараметрыПисьма.Вставить("Кому", ПочтовыйАдресПолучателя);
		ПараметрыПисьма.Вставить("ТипТекста", "HTML");
		
		МодульРаботаСПочтовымиСообщениями = ОбщегоНазначения.ОбщийМодуль("РаботаСПочтовымиСообщениями");
		Попытка
			УчетнаяЗапись = МодульРаботаСПочтовымиСообщениями.СистемнаяУчетнаяЗапись();
			Письмо = МодульРаботаСПочтовымиСообщениями.ПодготовитьПисьмо(УчетнаяЗапись, ПараметрыПисьма);
			МодульРаботаСПочтовымиСообщениями.ОтправитьПисьмо(УчетнаяЗапись, Письмо);
		Исключение
			ЗаписьЖурналаРегистрации(ВидСообщения,
				УровеньЖурналаРегистрации.Ошибка, , ,
				СтрШаблон(НСтр("ru = 'Ошибка при отправке уведомления: %1'"),
					ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())));
			Продолжить;
		КонецПопытки;
		
		ЗаписьЖурналаРегистрации(ВидСообщения,
			УровеньЖурналаРегистрации.Информация, , ,
			СтрШаблон(НСтр("ru = 'Уведомления успешно отправлены на адрес %1.'"), ПочтовыйАдресПолучателя));
		
		// - Установка признака ВыполненоУведомлениеПоТелеграм.
		Запись = РегистрыСведений.НапоминанияПользователя.СоздатьМенеджерЗаписи();
		ЗаполнитьЗначенияСвойств(Запись, Оповещение, "Пользователь, ВремяСобытия, Источник");
		Запись.Прочитать();
		Если Запись.Выбран() Тогда
			Запись.ВыполненоУведомлениеПоЭлектроннойПочте = Истина;
			Запись.Записать();
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Регламентное задание. Выполняет проверку наличия активных напоминаний для пользователя (о которых надо уведомить) и уведомляет по Телеграм.
Процедура УведомлениеПоНапоминаниямЧерезТелеграм() Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.УведомлениеПоНапоминаниямЧерезТелеграм);
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНапоминанияПользователя") Тогда
		Возврат;
	КонецЕсли;
	
	УведомитьПользователейПоНапоминаниямТелеграм();
	
КонецПроцедуры

// Уведомляет пользователей по напоминаниям телеграм
//
Процедура УведомитьПользователейПоНапоминаниямТелеграм() Экспорт
	
	ТаблицаОповещений = СписокТекущихНапоминанийПользователейПочтаТелеграм(Ложь, Истина);
	
	БотТелеграм = Справочники.ТелеграмБоты.БотДляОтправкиСообщенийЗадачПоУмолчанию();
	
	Для Каждого Оповещение Из ТаблицаОповещений Цикл
		
		// Отправка оповещения по Телеграм.
		ТекстСообщенияТелеграм = НСтр("ru = '[Напоминание по ""%1"", время события уведомления %2]
				|%3'");
		ТекстСообщенияТелеграм = СтрШаблон(ТекстСообщенияТелеграм, Оповещение.Источник, Оповещение.ВремяСобытия, Оповещение.Описание);
		
		РезультатОтправкиСообщения = ТелеграмСервер.ОтправитьСообщениеПользователю(БотТелеграм, Оповещение.Пользователь, ТекстСообщенияТелеграм);
		
		Если Не РезультатОтправкиСообщения.РезультатОтправки Тогда
			
			ЗаписьЖурналаРегистрации(НСтр("ru = 'НапоминанияПользователя.Уведомление по Телеграм о событии'",
				ОбщегоНазначения.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,,
				СтрШаблон(НСтр("ru = 'Уведомления не отправлены на телеграм %1.'"), Оповещение.Пользователь));
		
			Продолжить;
		
		КонецЕсли;
		
		ЗаписьЖурналаРегистрации(НСтр("ru = 'НапоминанияПользователя.Уведомление по Телеграм о событии'",
				ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Информация, , ,
			СтрШаблон(НСтр("ru = 'Уведомления успешно отправлены на телеграм %1.'"), Оповещение.Пользователь));
		
		// Установка признака ВыполненоУведомлениеПоТелеграм.
		Запись = РегистрыСведений.НапоминанияПользователя.СоздатьМенеджерЗаписи();
		ЗаполнитьЗначенияСвойств(Запись, Оповещение, "Пользователь, ВремяСобытия, Источник");
		Запись.Прочитать();
		Если Запись.Выбран() Тогда
			Запись.ВыполненоУведомлениеПоТелеграм = Истина;
			Запись.Записать();
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Полный список текущих активных напоминаний для пользователя с признаком "Уведомлять по Телеграм"
//
// Возвращаемое значение:
//  Массив из Структура:
//  * Пользователь - СправочникСсылка.Пользователи
//  * ВремяСобытия - Дата
//  * Источник - ОпределяемыйТип.ПредметНапоминания
//  * СрокНапоминания - Дата
//  * Описание - Строка
//  * ИндексКартинки - Число
//
Функция СписокТекущихНапоминанийПользователейПочтаТелеграм(УведомленияПочты = Истина, УведомленияТелеграм = Ложь) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Напоминания.Пользователь КАК Пользователь,
		|	Напоминания.ВремяСобытия КАК ВремяСобытия,
		|	Напоминания.Источник КАК Источник,
		|	Напоминания.СрокНапоминания КАК СрокНапоминания,
		|	Напоминания.Описание КАК Описание,
		|	2 КАК ИндексКартинки,
		|	Напоминания.УведомлятьПоТелеграм КАК УведомлятьПоТелеграм,
		|	Напоминания.УведомлятьПоЭлектроннойПочте КАК УведомлятьПоЭлектроннойПочте
		|ИЗ
		|	РегистрСведений.НапоминанияПользователя КАК Напоминания
		|ГДЕ
		|	Напоминания.СрокНапоминания <= &ТекущаяДата
		|	И &ОсновноеУсловие
		|	И НЕ Напоминания.Пользователь.Недействителен
		|	И НЕ Напоминания.Источник.ПометкаУдаления
		|
		|УПОРЯДОЧИТЬ ПО
		|	ВремяСобытия";
	
	
	ПодстановкаПочты = НСтр("ru = '(НЕ Напоминания.ВыполненоУведомлениеПоЭлектроннойПочте И Напоминания.УведомлятьПоЭлектроннойПочте)'");
	ПодстановкаТелеграм = НСтр("ru = '(НЕ Напоминания.ВыполненоУведомлениеПоТелеграм И Напоминания.УведомлятьПоТелеграм)'");
	ТекстПодстановки = "";
	
	Если УведомленияПочты
		И УведомленияТелеграм Тогда
		
		ШаблонПодстановки = НСтр("ru = '%1 ИЛИ %2'");
		ТекстПодстановки = СтрШаблон(ШаблонПодстановки, ПодстановкаПочты, ПодстановкаТелеграм);
		
	ИначеЕсли УведомленияТелеграм Тогда
		// только Телеграм
		ШаблонПодстановки = НСтр("ru = '%1'");
		ТекстПодстановки = СтрШаблон(ШаблонПодстановки, ПодстановкаТелеграм);
		
	Иначе
		// только Почта
		ШаблонПодстановки = НСтр("ru = '%1'");
		ТекстПодстановки = СтрШаблон(ШаблонПодстановки, ПодстановкаПочты);
		
	КонецЕсли;
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОсновноеУсловие", ТекстПодстановки);
	
	Запрос.УстановитьПараметр("ТекущаяДата", ТекущаяДатаСеанса());
	
	// BSLLS:SetPrivilegedMode-off
	УстановитьПривилегированныйРежим(Истина);
	// BSLLS:SetPrivilegedMode-on
	Результат = ОбщегоНазначения.ТаблицаЗначенийВМассив(Запрос.Выполнить().Выгрузить());
	
	Возврат Результат;
	
КонецФункции

// Полный аналог функции НапоминанияПользователя.НайтиНапоминания(), только ищет напоминания по всем пользователям
//
// Параметры:
//  Предмет - ЛюбаяСсылка
//          - Массив - предмет или предметы напоминания.
//  Идентификатор - Строка - уточняет предмет напоминания, например, "ДеньРождения".
//
// Возвращаемое значение:
//    Массив - коллекция напоминаний в виде структур с полями, соответствующими полям регистра сведений НапоминанияПользователя.
//
Функция НайтиНапоминанияПоВсемПользователям(Знач Предмет = Неопределено, Идентификатор = Неопределено) Экспорт
	
	ТекстЗапроса =
		"ВЫБРАТЬ
		|	*
		|ИЗ
		|	РегистрСведений.НапоминанияПользователя КАК НапоминанияПользователя
		|ГДЕ
		|	&ОтборПоПредмету
		|	И &ОтборПоИдентификатору";
	
	ОтборПоПредмету = "ИСТИНА";
	Если ЗначениеЗаполнено(Предмет) Тогда
		ОтборПоПредмету = "НапоминанияПользователя.Источник В(&Предмет)";
	КонецЕсли;
	
	ОтборПоИдентификатору = "ИСТИНА";
	Если ЗначениеЗаполнено(Идентификатор) Тогда
		ОтборПоИдентификатору = "НапоминанияПользователя.Идентификатор = &Идентификатор";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОтборПоПредмету", ОтборПоПредмету);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОтборПоИдентификатору", ОтборПоИдентификатору);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Предмет", Предмет);
	Запрос.УстановитьПараметр("Идентификатор", Идентификатор);
	
	ТаблицаНапоминаний = Запрос.Выполнить().Выгрузить();
	
	Возврат ОбщегоНазначения.ТаблицаЗначенийВМассив(ТаблицаНапоминаний);
	
КонецФункции


//////////////////////////////////////////////////////////////////////////////////////////
// РАБОТА С ВЕБ-СЕРВИСАМИ

// Выполняет HTTP запрос к серверу и возвращает результат в формате JSON.
// 
// Параметры:
//  АдресСервера     - Строка    - URL адрес сервера для отправки запроса.
//  АдресРесурса     - Строка    - URL путь ресурса на сервере, к которому отправляется запрос.
//  МетодОтправки    - Строка    - Метод отправки запроса (например, GET, PUT, POST).
//  ПараметрыЗапроса - Структура - Структура, содержащая параметры запроса, такие как текст запроса, заголовки, порт, таймаут и т.д.
// 
// Возвращаемое значение:
//  Структура - Значение ответа в формате JSON
//
Функция ВыполнитьЗапросHTTP_JSON(АдресСервера, АдресРесурса, МетодОтправки, ПараметрыЗапроса = Неопределено) Экспорт
	
	Результат = Новый Структура;
	
	Если ПараметрыЗапроса = Неопределено Тогда
		
		ПараметрыЗапроса = Новый Структура;
		
	КонецЕсли;
	
	Если ПараметрыЗапроса.Свойство("ЗначениеДляОтправки") Тогда
		
		ПараметрыЗапроса.Вставить("ТекстЗапроса", СтрокаИзJSON(ПараметрыЗапроса.ЗначениеДляОтправки));
		Результат.Вставить("ТекстЗапроса", ПараметрыЗапроса.ТекстЗапроса);
		
	КонецЕсли;
	
	Если Не ПараметрыЗапроса.Свойство("Заголовки") Тогда
		
		ПараметрыЗапроса.Вставить("Заголовки", Новый Соответствие);
		
	КонецЕсли;
	
	Если ПараметрыЗапроса.Заголовки["Content-Type"] = Неопределено Тогда
		
		ПараметрыЗапроса.Заголовки.Вставить("Content-Type", "application/json");
		
	КонецЕсли;
	
	Если Не ПараметрыЗапроса.Свойство("ПрочитатьВСоответствие") Тогда
		
		ПараметрыЗапроса.Вставить("ПрочитатьВСоответствие", Ложь);
		
	КонецЕсли;
	
	Ответ = ВыполнитьЗапросHTTP(АдресСервера, АдресРесурса, МетодОтправки, ПараметрыЗапроса);
	
	ТекстОтвета = Ответ.ПолучитьТелоКакСтроку();
	ЗначениеJSON = JSONИзСтроки(ТекстОтвета, ПараметрыЗапроса.ПрочитатьВСоответствие);
	Результат.Вставить("ЗначениеОтвета", ЗначениеJSON);
	
	// Прогоним ответ через запись JSON, чтобы получить нормальное форматирование.
	ТекстОтвета = СтрокаИзJSON(ЗначениеJSON);
	Результат.Вставить("ТекстОтвета", ТекстОтвета);
	
	Возврат Результат;
	
КонецФункции

// Выполняет HTTP запрос к заданному серверу и ресурсу с указанным методом отправки запроса.
// 
// Параметры:
//  АдресСервера     - Строка    - URL адрес сервера, к которому будет направлен запрос.
//  АдресРесурса     - Строка    - URL адрес ресурса на сервере, к которому будет направлен запрос.
//  МетодОтправки    - Строка    - Метод отправки запроса. Может принимать значения 'GET', 'PUT' или 'POST'. По умолчанию используется 'GET'.
//  ПараметрыЗапроса - Структура - Параметры запроса, такие как порт, таймаут, заголовки, использование аутентификации ОС, текст запроса и т.д.
// 
// Возвращаемое значение:
//  HTTPОтвет - представляющий результат выполнения HTTP запроса. Конкретный тип зависит от успешности выполнения.
//
Функция ВыполнитьЗапросHTTP(АдресСервера, АдресРесурса, МетодОтправки, ПараметрыЗапроса = Неопределено) Экспорт
	
	// Заполним параметры запроса значениями по умолчанию.
	Если ПараметрыЗапроса = Неопределено Тогда
		
		ПараметрыЗапроса = Новый Структура;
		
	КонецЕсли;
	
	Если Не ПараметрыЗапроса.Свойство("Порт") Тогда
		
		ПараметрыЗапроса.Вставить("Порт", Неопределено);
		
	КонецЕсли;
	
	Если Не ПараметрыЗапроса.Свойство("Таймаут") Тогда
		
		ПараметрыЗапроса.Вставить("Таймаут", 60);
		
	КонецЕсли;
	
	Если Не ПараметрыЗапроса.Свойство("Заголовки") Тогда
		
		ПараметрыЗапроса.Вставить("Заголовки", Новый Соответствие);
		
	КонецЕсли;
	
	Если Не ПараметрыЗапроса.Свойство("ИспользоватьАутентификациюОС") Тогда
		
		ПараметрыЗапроса.Вставить("ИспользоватьАутентификациюОС", Ложь);
		
	КонецЕсли;
	
	Если Не ПараметрыЗапроса.Свойство("ТекстЗапроса") Тогда
		
		ПараметрыЗапроса.Вставить("ТекстЗапроса", "");
		
	КонецЕсли;
	
	SSL = Новый ЗащищенноеСоединениеOpenSSL;
	HTTPСоединение = Новый HTTPСоединение(АдресСервера, ПараметрыЗапроса.Порт, , , , ПараметрыЗапроса.Таймаут, SSL, ПараметрыЗапроса.ИспользоватьАутентификациюОС);
	HTTPЗапрос = Новый HTTPЗапрос(АдресРесурса);
	
	Для каждого КлючИЗначение Из ПараметрыЗапроса.Заголовки Цикл
		
		HTTPЗапрос.Заголовки.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		
	КонецЦикла;
	
	HTTPЗапрос.УстановитьТелоИзСтроки(ПараметрыЗапроса.ТекстЗапроса);
	
	Если МетодОтправки = "GET" Тогда
		
		Ответ = HTTPСоединение.Получить(HTTPЗапрос);
		
	ИначеЕсли МетодОтправки = "PUT" Тогда
		
		Ответ = HTTPСоединение.Записать(HTTPЗапрос);
		
	ИначеЕсли МетодОтправки = "POST" Тогда
		
		Ответ = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
		
	Иначе
		
		ВызватьИсключение(НСтр("ru = 'Недопустимое значение условий функции.'"), КатегорияОшибки.ОшибкаКонфигурации);
		
	КонецЕсли;
	
	Возврат Ответ;
	
КонецФункции


//////////////////////////////////////////////////////////////////////////////////////////
// РАБОТА С JSON

// Конвертирует JSON строку в обычную строку.
// 
// Возвращаемое значение:
//  Структура - ЗначениеОтвета, ТекстОтвета
//
Функция СтрокаИзJSON(ЗначениеJSON) Экспорт
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ЗначениеJSON);
	СтрокаJSON = ЗаписьJSON.Закрыть();
	
	Возврат СтрокаJSON;
	
КонецФункции

// Конвертирует строку формата JSON в соответствующее значение.
// 
// Параметры:
//  СтрокаJSON             - Строка - Строка, содержащая данные в формате JSON.
//  ПрочитатьВСоответствие - Булево - Определяет, нужно ли приводить к соответствию типов при чтении JSON. По умолчанию Ложь.
// 
// Возвращаемое значение:
//  Произвольное - Возвращает соответствующее значение JSON или Неопределено, если произошла ошибка.
//
Функция JSONИзСтроки(СтрокаJSON, ПрочитатьВСоответствие = Ложь) Экспорт
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	
	Попытка
		
		ЗначениеJSON = ПрочитатьJSON(ЧтениеJSON, ПрочитатьВСоответствие);
		
	Исключение
	    
		ЗначениеJSON = Неопределено;
		ТекстОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки);
		
	КонецПопытки;
	
	Возврат ЗначениеJSON;
	
КонецФункции


//////////////////////////////////////////////////////////////////////////////////////////
// РАБОТА С НЕЙРОСЕТЬЮ GIGA-CHAT https://developers.sber.ru/docs/ru/gigachat/api/overview

// Возвращает ответ от нейросети
//
// Параметры:
//  Сообщение	 - Строка	 - текст сообщения для обработки
//  Промт		 - Строка	 - текст промта (не обязательный параметр)
// 
// Возвращаемое значение:
//   Структура:
//		* ОписаниеРезультат - Строка
//		* ПреобразованиеУспешно - Булево
//		* КодСостоянияAPI - Число - код возврата API (200, 400 и др 
//
Функция СформироватьОтветОтНейросети(Сообщение, Промт = "") Экспорт

	Результат = Новый Структура;
	Результат.Вставить("ОписаниеРезультат", "");
	Результат.Вставить("ПреобразованиеУспешно", Ложь);
	Результат.Вставить("КодСостоянияAPI", 0);

	ТокенАвторизации = ТокенДоступаНейросети();	

	Если Не ЗначениеЗаполнено(ТокенАвторизации) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Настройки = Новый Структура; 
	Настройки.Вставить("Заголовки", ЗаголовкиGigaChat(ТокенАвторизации));

	Настройки.Вставить("Json", ДанныеДляСообщения(Сообщение, Промт));

	РезультатPost = КоннекторHTTP.Post("https://gigachat.devices.sberbank.ru/api/v1/chat/completions",, Настройки);
	РезультатИзJson = КоннекторHTTP.КакJson(РезультатPost);
	
	Результат.КодСостоянияAPI = РезультатPost.КодСостояния;
	Если РезультатPost.КодСостояния = 200 Тогда
		Результат.ПреобразованиеУспешно = Истина;
	    Результат.ОписаниеРезультат = РезультатИзJson["choices"][0]["message"]["content"];
	КонецЕсли;
	
	Возврат Результат;

КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПРОЧИЕ ФУНКЦИИ И ПРОЦЕДУРЫ

// Текст из HTML
//
// Параметры:
//  ТекстHTML	 - Строка
//
// Возвращаемое значение:
//   Строка - очищенная строка от HTML
//
Функция ТекстИзHTML(ТекстHTML) Экспорт
	
	ФорматированныйДокумент = Новый ФорматированныйДокумент;
	ФорматированныйДокумент.УстановитьHTML(ТекстHTML, Новый Структура);
	ПростойТекст = ФорматированныйДокумент.ПолучитьТекст();
	
	Возврат ПростойТекст;
	
КонецФункции

// Текст в HTML
//
// Параметры:
//  Текст  - Строкм - простой текст
//
// Возвращаемое значение:
//   Строка - текст преобразованный в html
//
Функция ТекстВHTML(Текст) Экспорт
	
	Если СтрНайти(НРег(Текст), "</html>", НаправлениеПоиска.СКонца) > 0 Тогда
		Возврат Текст;
	КонецЕсли;
	
	ДокументHTML = Новый ДокументHTML;
	
	ЭлементТело = ДокументHTML.СоздатьЭлемент("body");
	ДокументHTML.Тело = ЭлементТело;
	
	Для НомерСтроки = 1 По СтрЧислоСтрок(Текст) Цикл
		Строка = СтрПолучитьСтроку(Текст, НомерСтроки);
		
		ЭлементБлок = ДокументHTML.СоздатьЭлемент("p");
		ЭлементТело.ДобавитьДочерний(ЭлементБлок);
		
		ЭлементТекст = ДокументHTML.СоздатьТекстовыйУзел(Строка);
		ЭлементБлок.ДобавитьДочерний(ЭлементТекст);
	КонецЦикла;
	
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьHTML = Новый ЗаписьHTML;
	ЗаписьHTML.УстановитьСтроку();
	ЗаписьDOM.Записать(ДокументHTML, ЗаписьHTML);
	Результат = ЗаписьHTML.Закрыть();
	
	Возврат Результат;
	
КонецФункции

// Удалить пустые строки таблицы значений
//
// Параметры:
//  ТаблицаЗначений				 - 	ТаблицаЗначений 
//  СтруктураОтбораПустыхПолей	 - 	Параметры отбора пустых строк 
// 
// Возвращаемое значение:
//  ТаблицаЗначений - с учетом удаленных по СтруктураОтбораПустыхПолей строк  
//
Функция УдалитьПустыеСтрокиТаблицыЗначений(ТаблицаЗначений, СтруктураОтбораПустыхПолей) Экспорт

	МассивПустыхСтрок = ТаблицаЗначений.НайтиСтроки(СтруктураОтбораПустыхПолей);
	Для Каждого СтрокаМассива Из МассивПустыхСтрок Цикл
		ТаблицаЗначений.Удалить(СтрокаМассива);
	КонецЦикла;	
	
	Возврат ТаблицаЗначений;

КонецФункции

// Функция возвращает таблицу разницы отсортированную по "Измерения"
//  Код взят из: https://infostart.ru/public/326983/: Свертка и сортировка
//
// Параметры:
//  Таблица1						 - ТаблицаЗначений	 - содержит первую сравниваемую таблицу
//  Таблица2						 - ТаблицаЗначений	 - содержит вторую сравниваемую таблицу
//  Измерения						 - Строка			 - поле по которому будет сделана сортировка
//  УдалятьКолонкиИзПервойТаблицы	 - Булево			 - в случае Истина, удаляются колонки из первой таблицы, которых нет во второй таблице
// 
// Возвращаемое значение:
//  ТаблицаЗначений - таблица разницы значений. Состоит из колонок:
//  * КолонкаN - КолонкиТаблицыЗначений
//  * Знак - Число - 0 есть в таблице 0, 1 есть в таблице 1
//
Функция РазницаТаблицЗначений(Таблица1, Таблица2, Измерения = Неопределено, УдалятьКолонкиИзПервойТаблицы = Ложь) Экспорт
    	
	Если УдалятьКолонкиИзПервойТаблицы Тогда
	    УдалитьОтсутствующиеКолонкиИзТаблицыЗначений(Таблица1, Таблица2);	
	КонецЕсли;
	    
	// Все колонки Таблица1.
	ВсеКолонки = "";
    Для Каждого Колонка Из Таблица1.Колонки Цикл 
        ВсеКолонки = ВсеКолонки + ", " + Колонка.Имя;
    КонецЦикла;
    ВсеКолонки = Сред(ВсеКолонки, 2);
		
    Таблица = Таблица2.Скопировать();    
    
    Таблица.Колонки.Добавить("Знак", Новый ОписаниеТипов("Число"));
    Таблица.ЗаполнитьЗначения(1, "Знак");
    
	Для Каждого Строка Из Таблица1 Цикл 
		ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Строка); 
	КонецЦикла;
    
    Таблица.Колонки.Добавить("Счёт");
    Таблица.ЗаполнитьЗначения(1, "Счёт");
		
	Таблица.Свернуть(ВсеКолонки, "Знак, Счёт");
	
	ОтборПоСчету = Новый Структура("Счёт", 1);
    Ответ = Таблица.Скопировать(ОтборПоСчету, ВсеКолонки + ", Знак");
	
	Если Измерения <> Неопределено Тогда
		
	    Ответ.Сортировать(Измерения);
		
	КонецЕсли;
    
    Возврат Ответ;
    
КонецФункции

// Сравнивает две таблицы значений на равенство по всем измерениям. При этом не учитывается порядок строк.
//
// Параметры:
//  Таблица1                      - ТаблицаЗначений
//  Таблица2                      - ТаблицаЗначений
//	СравниватьКолонки             - Булево - в случае Истина, будет сравнивать колонки и по результату выдавать меньшее кол-во. 
//								    Если колонки не сравнивать и они будут отличаться, то будет ошибка выполнения функции. По-умолчанию: Ложь.
//  Измерения	                  - Строка - поле по которому будет сделана сортировка
//  УдалятьКолонкиИзПервойТаблицы - Булево - в случае Истина, удаляются колонки из первой таблицы, которых нет во второй таблице
// 
// Возвращаемое значение:
//  Булево
//
Функция ТаблицыЗначенийРавны(Таблица1, Таблица2, СравниватьКолонки = Ложь, Измерения = Неопределено, УдалятьКолонкиИзПервойТаблицы = Ложь) Экспорт
	
	Если Не ЗначениеЗаполнено(Таблица1)
		И Не ЗначениеЗаполнено(Таблица2) Тогда
		
		Возврат Истина;
		
	ИначеЕсли ЗначениеЗаполнено(Таблица1)
		И Не ЗначениеЗаполнено(Таблица2) Тогда
		
		Возврат Ложь;
		
	ИначеЕсли Не ЗначениеЗаполнено(Таблица1)
		И ЗначениеЗаполнено(Таблица2) Тогда
		
		Возврат Ложь;
	Иначе
		// без обработки
	КонецЕсли;
	
	Если СравниватьКолонки Тогда
		Для Каждого Колонка Из Таблица1.Колонки Цикл
			Если Таблица2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;		
		КонецЦикла;	
		Для Каждого Колонка Из Таблица2.Колонки Цикл
			Если Таблица1.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;		
		КонецЦикла;
	КонецЕсли;
		
	Разница = РазницаТаблицЗначений(Таблица1, Таблица2, Измерения, УдалятьКолонкиИзПервойТаблицы);
	
	Возврат (Разница.Количество() = 0);
	
КонецФункции

// Удаляет колонки из первой таблицы, которых нет во второй таблице.
//
// Параметры:
//  Таблица1	 - ТаблицаЗначений.
//  Таблица2	 - ТаблицаЗначений.
//
Процедура УдалитьОтсутствующиеКолонкиИзТаблицыЗначений(Таблица1, Таблица2) Экспорт 
		
	Если Не ЗначениеЗаполнено(Таблица1) 
		Или Не ЗначениеЗаполнено(Таблица2) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	КолонкиКУдалению = Новый Массив;
	
	Для Каждого Колонка Из Таблица1.Колонки Цикл
		Если Таблица2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
			КолонкиКУдалению.Добавить(Колонка.Имя);
		КонецЕсли;		
	КонецЦикла;	         
	
	Для каждого Колонка Из КолонкиКУдалению Цикл
		Таблица1.Колонки.Удалить(Колонка);	
	КонецЦикла;
		
КонецПроцедуры

// Сравнивает реквизиты по списку и возвращает флаг изменения.
//
// Параметры:
//  Объект						 - ЛюбойОбъект 
//  СтараяСсылка				 - ДокументСсылка, СправочникСсылка 
//  СписокРеквизитовСравнения	 - Массив Из Строка - список реквизитов, которые надо выгрузить 
//  УжеЕстьИзменения			 - Булево - если ранее уже были определения изменений, то передавать флаг об этом
//  ИзмененныеРеквизиты			 - Строка - в строке передает описание изменений для логов
// 
// Возвращаемое значение:
//  Булево - Истина, если есть изменения реквизитов
//
Функция ЕстьИзмененияРеквизитовОбъекта(Объект, СтараяСсылка, СписокРеквизитовСравнения, УжеЕстьИзменения = Ложь, ИзмененныеРеквизиты = "") Экспорт
	
	Если УжеЕстьИзменения Тогда
		Возврат Истина;
	КонецЕсли;
	
	СписокРеквизитов = СтрСоединить(СписокРеквизитовСравнения, ", ");
	
	РеквизитыСсылки = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(СтараяСсылка, СписокРеквизитов);
	
	ЕстьИзменения = Ложь;
	
	Для каждого ТекСтрока Из РеквизитыСсылки Цикл
		
		ЕстьИзмененияПоОдномуРеквизиту = Ложь;
	
		ОбщегоНазначенияКупоросКлиентСервер.СравнитьРеквизит(Объект, ТекСтрока.Ключ, ТекСтрока.Значение, ЕстьИзмененияПоОдномуРеквизиту);
		
		Если ЕстьИзмененияПоОдномуРеквизиту Тогда
			ИзмененныеРеквизиты = СтрШаблон(НСтр("ru = '%1 {%2: [%3] -> [%4]}'"), ИзмененныеРеквизиты, ТекСтрока.Ключ, Объект[ТекСтрока.Ключ], ТекСтрока.Значение);
		КонецЕсли;
		
		// ЕстьИзменения не менять, если хотя бы раз выявилось изменение.
		ЕстьИзменения = ?(ЕстьИзмененияПоОдномуРеквизиту, Истина, ЕстьИзменения);
		
	КонецЦикла;
	
	ИзмененныеРеквизиты = СокрЛП(ИзмененныеРеквизиты);
	
	Возврат ЕстьИзменения;

КонецФункции

// Сравнивает табличные части по списку и возвращает флаг изменения.
//
// Параметры:
//  Объект							 - ЛюбойОбъект - текущий объект для сравнения
//  СтараяСсылка					 - ЛюбаяСсылка - ссылка, которую сравниваем с текущим объектом
//  СписокТабличныхЧастейСравнения	 - Массив Из Строка	 - перечень имен табличных частей для сравнения
//  УжеЕстьИзменения				 - Булево	 - нужен если подряд несколько раз вызывается функция и надо отсечь выполнение, если уже есть изменения 
// 
// Возвращаемое значение:
//  Булево - Истина, если есть изменения
//
Функция ЕстьИзмененияТабличныхЧастейОбъект(Объект, СтараяСсылка, СписокТабличныхЧастейСравнения, УжеЕстьИзменения = Ложь) Экспорт
	
	Если УжеЕстьИзменения Тогда
		Возврат Истина;
	КонецЕсли;
	
	ЕстьИзменения = Ложь;
	
	Для каждого ТекСтрока Из СписокТабличныхЧастейСравнения Цикл
		
		ТаблицаДоИзменения = СтараяСсылка[ТекСтрока].Выгрузить();
		ТаблицаПослеИзменения = Объект[ТекСтрока].Выгрузить();
		
		Если Не ОбщегоНазначенияКупоросСервер.ТаблицыЗначенийРавны(ТаблицаДоИзменения, ТаблицаПослеИзменения) Тогда
			ЕстьИзменения = Истина;
			Прервать;
		КонецЕсли;
	
	КонецЦикла;
	
	Возврат ЕстьИзменения;
	
КонецФункции

#КонецОбласти  

#Область СлужебныеПроцедурыИФункции

#Область РаботаСНейросетью

Функция ТокенДоступаНейросети()
	
	АвторизационныйКлючАПИНейросети = РегистрыСведений.ПараметрыКупорос.ЗначениеПараметра("АвторизационныйКлючАПИНейросети");
	
	Если Не ЗначениеЗаполнено(АвторизационныйКлючАПИНейросети) Тогда
		ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Не введен в настройках ключ авторизации АПИ Нейросети.'"));
		Возврат "";
	КонецЕсли;
	
	ТокенАвторизации = РегистрыСведений.ПараметрыКупорос.ЗначениеПараметра("ТокенНейросети");	
	
	// Проверка на то, что токен не истек
	ТребуетсяПолучитьТокенДоступа = Ложь;
	Если ЗначениеЗаполнено(ТокенАвторизации) Тогда
		// Get - Получение списка моделей.
		Настройки = Новый Структура; 
		Настройки.Вставить("Заголовки", ЗаголовкиGigaChat(ТокенАвторизации));
		
		РезультатGet = КоннекторHTTP.Get("https://gigachat.devices.sberbank.ru/api/v1/models",, Настройки);
		ТребуетсяПолучитьТокенДоступа = РезультатGet.КодСостояния = 401;
		
	Иначе
		
		ТребуетсяПолучитьТокенДоступа = Истина;	
		
	КонецЕсли;
	
	Если Не ТребуетсяПолучитьТокенДоступа Тогда
		Возврат ТокенАвторизации;	
	КонецЕсли;
	
	// Получение нового токена доступа.
	Настройки = Новый Структура; 
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	Заголовки.Вставить("Accept", "application/json");
	Заголовки.Вставить("Accept-Encoding", "gzip, deflate, br");
	Заголовки.Вставить("RqUID", Строка(Новый УникальныйИдентификатор()));
	Заголовки.Вставить("Authorization", "Bearer " + АвторизационныйКлючАПИНейросети);

	Настройки.Вставить("Заголовки", Заголовки);

	Данные = Новый Структура;
	Данные.Вставить("scope", "GIGACHAT_API_PERS");
	
	РезультатВыполнения = КоннекторHTTP.Post("https://ngw.devices.sberbank.ru:9443/api/v2/oauth", Данные, Настройки);
	РезультатJson = КоннекторHTTP.КакJson(РезультатВыполнения);
	
	Если РезультатВыполнения.КодСостояния <> 200 Тогда
		ТекстОшибки = НСтр("ru = 'Ошибка API при получении нового токена доступа.'"); 
		ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
		
		ЗаписьЖурналаРегистрацииРасширенная("РаботаСНейросетью", 
				ТекстОшибки, 
				УровеньЖурналаРегистрации.Ошибка);
		
		Возврат "";	
	КонецЕсли;
	
	ТокенАвторизации = РезультатJson["access_token"];
	
	// Сохранить в параметрах токен нейросети.
	ЗначениеНовыхПараметров = Новый Структура("ТокенНейросети", ТокенАвторизации);
	РегистрыСведений.ПараметрыКупорос.ДобавитьЗначенияПараметров(ЗначениеНовыхПараметров);	
	
	Возврат ТокенАвторизации;

КонецФункции

Функция ЗаголовкиGigaChat(ТокенАвторизации)
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Authorization", "Bearer " + ТокенАвторизации);
	Заголовки.Вставить("Content-Type", "application/json");
	Заголовки.Вставить("Accept", "*/*");
	Заголовки.Вставить("Accept-Encoding", "gzip, deflate, br");
	Заголовки.Вставить("Connection", "keep-alive");
	
	Возврат Заголовки;

КонецФункции

Функция ДанныеДляСообщения(Сообщение, Промт = "")
    // https://developers.sber.ru/docs/ru/gigachat/api/reference/rest/post-chat
	
	Данные = Новый Структура;
	Данные.Вставить("model", "GigaChat");
	Данные.Вставить("stream", Ложь);
	Данные.Вставить("update_interval", 0);
	// сообщение
	МассивСообщений = Новый Массив;
	
	Если ЗначениеЗаполнено(Промт) Тогда
		
		ТекущееСообщение = Новый Структура;
		ТекущееСообщение.Вставить("role", "system");
		ТекущееСообщение.Вставить("content", Промт);
		МассивСообщений.Добавить(ТекущееСообщение);
		
	КонецЕсли;
	
	ТекущееСообщение = Новый Структура;
	ТекущееСообщение.Вставить("role", "user");
	ТекущееСообщение.Вставить("content", Сообщение);
	МассивСообщений.Добавить(ТекущееСообщение);
	
	Данные.Вставить("messages", МассивСообщений);
	
	Возврат Данные;

КонецФункции

#КонецОбласти

#КонецОбласти
